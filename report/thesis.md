---
title: "Thesis"
bibliography: bib/thesis.bib
author: "Daan Spijkers"
---

# Thesis Draft

## Abstract

## Introduction

<!-- (Optional) necessary background -->
## Preliminaries

## Research

### Problem details
### Solution Details

#### Pseudocode
Simple pseudocode for our process is as follows:

~~~ python
def bccdgs(pag):
  mag = pag_to_mag(pag)
  next_mag = next_mag(mag)

  while score(next_mag) > score(mag):
    mag = next_mag
    next_mag = best_scoring_mag(adjacent_mags(mag))
  return mag_to_pag(mag)
~~~

Here we see that there are 4 main problems that we need to solve:

  1. Transforming a PAG into a MAG.
  2. Generating adjacent mags.
  3. Scoring a MAG.
  4. Transforming a MAG into a PAG

#### PAG to MAG
The main difference is circle marks. The way to do this is by first
orienting all semi-arcs into arcs, and then orienting all remaining edges
into a DAG with no unshielded colliders. See Zhang paper.

#### MAG to PAG
Turning a MAG back into a PAG is slightly more involved. We use
d-separation and the FCI orientation rules to do so.

#### Generating adjacent MAGS
This is the simplest problem to solve. We consider adjacent graphs to be
graphs which have one edge changed compared to the original. Given two
vertices $u$ and $v$, there are four possibilities:
\begin{align}
  u \rightarrow v \\
  u \leftarrow v \\
  u \leftrightarrow v\\
  (u, v) \notin E
\end{align}
Remembering that we ignored selection bias, and so there are no undirected
edges. Our original graph has one of these four. All adjacent MAGS can
then be easily generated by adding a graph which has one of the other 3
possibilities.

The real issue comes up when we want to check whether this MAG is also
valid; that is whether it has any almost directed cycles.

#### Scoring a MAG
Scoring is not necessarily the most difficult part, but it is more
unique to our problem, and did not have a readily available
implementation. We have implemented 3 checks:

  1. Ancestor(x, y)
  2. Edge(x, y)
  3. Cofounder(x, y)

### Results

![nodes pag](./lib/nodes_pag.pdf)
![nodes causal](./lib/nodes_causal.pdf)
![skel pag](./lib/skel_pag.pdf)
![skel causal](./lib/skel_causal.pdf)
![sparsity pag](./lib/sparsity_pag.pdf)
![sparsity causal](./lib/sparsity_causal.pdf)

#### Benchmarks
While the bccd portion, as well as the fci portion are both measured in
seconds, the greedy search is only several miliseconds.

## Related Work

## Conclusion

## References


